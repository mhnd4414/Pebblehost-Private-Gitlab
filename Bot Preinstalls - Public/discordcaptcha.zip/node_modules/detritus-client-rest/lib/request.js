"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const bucket_1 = require("./bucket");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
class RestRequest {
    constructor(client, request, options = {}) {
        this.client = client;
        this.request = request;
        if (this.shouldRatelimitCheck) {
            if (client.isBot) {
                request.options.headers[constants_1.RatelimitHeaders.PRECISION] = constants_1.RatelimitPrecisionTypes.MILLISECOND;
            }
            if (request.route) {
                this.bucketPath = `${request.route.method}-${request.route.path}`;
            }
        }
        this.errorOnRatelimit = options.errorOnRatelimit;
        this.maxRetries = 5;
        this.retries = 0;
        this.retryDelay = 2000;
        this.skipRatelimitCheck = options.skipRatelimitCheck;
    }
    get bucket() {
        if (this.bucketKey) {
            return this.client.buckets.get(this.bucketKey) || null;
        }
        return null;
    }
    get bucketHash() {
        if (this._bucketHash) {
            return this._bucketHash;
        }
        if (!this.skipRatelimitCheck && this.request.route && this.shouldRatelimitCheck) {
            const path = this.bucketPath;
            if (this.client.isBot) {
                if (this.client.routes.has(path)) {
                    return this._bucketHash = this.client.routes.get(path);
                }
            }
            else {
                return this._bucketHash = path;
            }
        }
        return null;
    }
    get bucketKey() {
        if (this._bucketKey) {
            return this._bucketKey;
        }
        if (this.request.route) {
            const bucketHash = this.bucketHash;
            if (bucketHash) {
                let major = '';
                for (let param of constants_1.RATELIMIT_BUCKET_MAJOR_PARAMS) {
                    if (param in this.request.route.params) {
                        major += this.request.route.params[param].trim();
                    }
                    major += '-';
                }
                return this._bucketKey = `${bucketHash}.${major.slice(0, -1)}`;
            }
        }
        return null;
    }
    get shouldRatelimitCheck() {
        return ((this.client.restClient.baseUrl instanceof url_1.URL) &&
            (this.client.restClient.baseUrl.host === this.request.url.host));
    }
    sendRequest() {
        return new Promise((resolve, reject) => {
            if (this.shouldRatelimitCheck && !this.errorOnRatelimit) {
                if (this.client.globalBucket.locked) {
                    return this.client.globalBucket.add({ request: this, resolve, reject });
                }
                const bucket = this.bucket;
                if (bucket) {
                    if (bucket.locked) {
                        return bucket.add({ request: this, resolve, reject });
                    }
                    if (bucket.ratelimit.remaining === 1) {
                        const ratelimit = bucket.ratelimit;
                        const diff = Math.min(0, ratelimit.resetAtLocal - Date.now());
                        if (diff) {
                            bucket.lock(diff);
                        }
                    }
                }
            }
            resolve(this.request.send());
        });
    }
    async send() {
        const response = await this.sendRequest();
        this.client.emit(constants_1.RestEvents.RESPONSE, { response, restRequest: this });
        if (this.shouldRatelimitCheck) {
            let bucket = null;
            if (this.request.route) {
                // reason for this check is just incase the request doesnt have one and we will still check the global ratelimit
                let shouldHaveBucket = false;
                if (this.client.isBot) {
                    if (constants_1.RatelimitHeaders.BUCKET in response.headers) {
                        this.client.routes.set(this.bucketPath, response.headers[constants_1.RatelimitHeaders.BUCKET]);
                        shouldHaveBucket = true;
                    }
                    else {
                        // no ratelimit on this path
                    }
                }
                else {
                    // users dont get the above header
                    shouldHaveBucket = true;
                }
                if (shouldHaveBucket && !this.skipRatelimitCheck) {
                    bucket = this.bucket;
                    if (!bucket) {
                        bucket = new bucket_1.Bucket(this.bucketKey);
                        this.client.buckets.insert(bucket);
                    }
                }
            }
            if (bucket) {
                if (constants_1.RatelimitHeaders.LIMIT in response.headers) {
                    bucket.setRatelimit(parseInt(response.headers[constants_1.RatelimitHeaders.LIMIT]), parseInt(response.headers[constants_1.RatelimitHeaders.REMAINING]), (parseFloat(response.headers[constants_1.RatelimitHeaders.RESET]) || 0) * 1000, (parseFloat(response.headers[constants_1.RatelimitHeaders.RESET_AFTER]) || 0) * 1000);
                }
                const ratelimit = bucket.ratelimit;
                if (ratelimit.remaining <= 0 && response.statusCode !== 429) {
                    const diff = ratelimit.resetAfter;
                    if (diff) {
                        bucket.lock(diff);
                    }
                }
            }
            if (response.statusCode === 429 && !this.errorOnRatelimit) {
                // ratelimited, retry
                let retryAfter = parseInt(response.headers[constants_1.RatelimitHeaders.RETRY_AFTER]) || 0;
                // since discord's retry-after is in milliseconds (should be seconds, like cloudflare)
                // described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
                const isDiscordRatelimit = ('via' in response.headers);
                if (!isDiscordRatelimit) {
                    retryAfter *= 1000;
                }
                return new Promise(async (resolve, reject) => {
                    const delayed = { request: this, resolve, reject };
                    if (this.client.isBot) {
                        if (response.headers[constants_1.RatelimitHeaders.GLOBAL] === 'true') {
                            this.client.globalBucket.lock(retryAfter);
                            this.client.globalBucket.add(delayed);
                            return response.close();
                        }
                    }
                    else {
                        if (isDiscordRatelimit) {
                            // check json body since users dont get the above header
                            const data = await response.body();
                            if (data.global) {
                                this.client.globalBucket.lock(retryAfter);
                                this.client.globalBucket.add(delayed);
                                return response.close();
                            }
                        }
                    }
                    if (bucket) {
                        bucket.ratelimit.remaining = 0;
                        bucket.ratelimit.resetAfter = retryAfter;
                        bucket.lock(retryAfter);
                        bucket.add(delayed, true);
                        return response.close();
                    }
                    // unsure of what to do since we should've gotten global ratelimited
                    await response.buffer();
                    return reject(new errors_1.HTTPError(response));
                });
            }
            if (bucket && bucket.size) {
                this.client.buckets.resetExpire(bucket);
            }
        }
        if (response.statusCode === 502 && this.maxRetries <= this.retries++) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.request.send().then(resolve).catch(reject);
                }, this.retryDelay);
                return response.close();
            });
        }
        const data = await response.body();
        if (!response.ok) {
            if (data && typeof (data) === 'object') {
                if ((this.client.restClient.baseUrl instanceof url_1.URL) &&
                    (this.client.restClient.baseUrl.host === this.request.url.host)) {
                    throw new errors_1.DiscordHTTPError(response, data);
                }
                else {
                    throw new errors_1.HTTPError(response, data.message, data.code);
                }
            }
            else {
                throw new errors_1.HTTPError(response);
            }
        }
        return response;
    }
}
exports.RestRequest = RestRequest;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const blankPrefixes = Object.freeze(['']);
/**
 * Command Argument
 * @category Command
 */
class Argument {
    constructor(options) {
        this._aliases = [];
        this._type = constants_1.CommandArgumentTypes.STRING;
        this.default = undefined;
        this.prefixes = new Set(['-']);
        options = Object.assign({}, options);
        if (options.metadata !== undefined) {
            this.metadata = Object.assign({}, options.metadata);
        }
        if (options.prefix !== undefined) {
            if (!options.prefixes) {
                options.prefixes = [];
            }
            options.prefixes.push(options.prefix);
        }
        if (options.prefixes) {
            options.prefixes.sort((x, y) => y.length - x.length);
            if (options.prefixes.some((prefix) => prefix.endsWith(' '))) {
                options.prefixSpace = true;
            }
            this.prefixes.clear();
            for (let prefix of options.prefixes) {
                if (!prefix) {
                    continue;
                }
                prefix = prefix.trim();
                if (options.prefixSpace) {
                    prefix += ' ';
                }
                if (prefix) {
                    this.prefixes.add(prefix);
                }
            }
        }
        this.default = options.default;
        this.name = options.name.toLowerCase();
        if (options.aliases) {
            this.aliases = options.aliases;
        }
        if (options.label) {
            this.label = options.label;
        }
        if (options.type) {
            this.type = options.type;
        }
    }
    get aliases() {
        return this._aliases;
    }
    set aliases(value) {
        this._aliases = (value || []).map((alias) => alias.toLowerCase());
    }
    get label() {
        return this._label || this.name;
    }
    set label(value) {
        this._label = value;
    }
    get names() {
        const names = [];
        const prefixes = (this.prefixes.size) ? this.prefixes : blankPrefixes;
        for (let prefix of prefixes) {
            names.push((prefix) ? prefix + this.name : this.name);
            for (let alias of this.aliases) {
                names.push((prefix) ? prefix + alias : alias);
            }
        }
        return names;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        switch (value) {
            case Boolean:
                {
                    value = constants_1.CommandArgumentTypes.BOOL;
                }
                ;
                break;
            case Number:
                {
                    value = constants_1.CommandArgumentTypes.NUMBER;
                }
                ;
                break;
            case String:
                {
                    value = constants_1.CommandArgumentTypes.STRING;
                }
                ;
                break;
        }
        this._type = (value || this.type);
        switch (this.type) {
            case constants_1.CommandArgumentTypes.BOOL:
                {
                    this.default = !!this.default;
                }
                ;
                break;
        }
    }
    check(name) {
        return this.names.some((n) => n === name);
    }
    getInfo(content) {
        const info = { index: -1, name: '' };
        for (let name of this.names) {
            const index = content.indexOf(name);
            if (index !== -1) {
                info.index = index;
                info.name = name;
                break;
            }
        }
        return info;
    }
    getName(content) {
        for (let name of this.names) {
            if (name.includes(' ')) {
                const parts = name.split(' ');
                let matches = true;
                let copy = content;
                let store = '';
                for (let [key, part] of parts.entries()) {
                    if (copy.length === part.length) {
                        if (copy === part) {
                            store += copy;
                            copy = '';
                            continue;
                        }
                    }
                    else {
                        if (copy.startsWith(part + ' ')) {
                            store += part;
                            copy = copy.slice(part.length);
                            if (key !== (parts.length - 1)) {
                                while (copy.startsWith(' ')) {
                                    store += ' ';
                                    copy = copy.slice(1);
                                }
                            }
                            continue;
                        }
                    }
                    matches = false;
                    break;
                }
                if (matches) {
                    return store;
                }
            }
            else {
                if (content.length === name.length) {
                    if (content === name) {
                        return name;
                    }
                }
                else {
                    if (content.startsWith(name + ' ')) {
                        return name;
                    }
                }
            }
        }
        return null;
    }
    async parse(value, context) {
        let parsedValue = value || this.default;
        if (typeof (this.type) === 'function') {
            parsedValue = await Promise.resolve(this.type(value, context));
        }
        else {
            switch (this.type) {
                case constants_1.CommandArgumentTypes.BOOL:
                    {
                        parsedValue = !this.default;
                    }
                    ;
                    break;
                case constants_1.CommandArgumentTypes.FLOAT:
                    {
                        parsedValue = parseFloat(value);
                    }
                    ;
                    break;
                case constants_1.CommandArgumentTypes.NUMBER:
                    {
                        parsedValue = parseInt(value);
                    }
                    ;
                    break;
            }
        }
        return parsedValue;
    }
}
exports.Argument = Argument;

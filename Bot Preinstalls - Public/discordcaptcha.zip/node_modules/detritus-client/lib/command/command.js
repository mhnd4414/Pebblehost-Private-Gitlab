"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const argument_1 = require("./argument");
const argumentparser_1 = require("./argumentparser");
const ratelimit_1 = require("./ratelimit");
/**
 * Command itself
 * @category Command
 */
class Command {
    constructor(commandClient, options) {
        this.disableDm = false;
        this.disableDmReply = false;
        this.metadata = {};
        this.priority = 0;
        this.ratelimits = [];
        this.responseOptional = false;
        this.commandClient = commandClient;
        this.arg = new argument_1.Argument(Object.assign({ prefix: '' }, options, { metadata: undefined }));
        this.args = new argumentparser_1.ArgumentParser(options.args);
        this.disableDm = !!options.disableDm;
        this.disableDmReply = !!options.disableDmReply;
        this.metadata = Object.assign(this.metadata, options.metadata);
        this.permissions = options.permissions;
        this.permissionsClient = options.permissionsClient;
        this.priority = options.priority || this.priority;
        this.responseOptional = !!options.responseOptional;
        if (options._file) {
            this._file = options._file;
        }
        if (options.ratelimit) {
            this.ratelimits.push(new ratelimit_1.CommandRatelimit(options.ratelimit));
        }
        if (options.ratelimits) {
            for (let rOptions of options.ratelimits) {
                const rType = (rOptions.type || '').toLowerCase();
                if (this.ratelimits.some((ratelimit) => ratelimit.type === rType)) {
                    throw new Error(`Ratelimit with type ${rType} already exists`);
                }
                this.ratelimits.push(new ratelimit_1.CommandRatelimit(rOptions));
            }
        }
        Object.defineProperties(this, {
            _file: { configurable: true, writable: false },
            client: { enumerable: false, writable: false },
            commandClient: { enumerable: false, writable: false },
        });
        this.onBefore = options.onBefore || this.onBefore;
        this.onBeforeRun = options.onBeforeRun || this.onBeforeRun;
        this.onCancel = options.onCancel || this.onCancel;
        this.onCancelRun = options.onCancelRun || this.onCancelRun;
        this.onError = options.onError || this.onError;
        this.onPermissionsFail = options.onPermissionsFail || this.onPermissionsFail;
        this.onPermissionsFailClient = options.onPermissionsFailClient || this.onPermissionsFailClient;
        this.run = options.run || this.run;
        this.onRatelimit = options.onRatelimit || this.onRatelimit;
        this.onRunError = options.onRunError || this.onRunError;
        this.onSuccess = options.onSuccess || this.onSuccess;
        this.onTypeError = options.onTypeError || this.onTypeError;
    }
    get aliases() {
        return this.arg.aliases;
    }
    set aliases(value) {
        this.arg.aliases = value;
    }
    get label() {
        return this.arg.label;
    }
    set label(value) {
        this.arg.label = value;
    }
    get name() {
        return this.arg.name;
    }
    set name(value) {
        this.arg.name = value.toLowerCase();
    }
    get names() {
        return this.arg.names;
    }
    set type(value) {
        this.arg.type = value;
    }
    check(name) {
        return this.arg.check(name);
    }
    async getArgs(attributes, context) {
        const { errors, parsed } = await this.args.parse(attributes, context);
        try {
            parsed[this.label] = await this.arg.parse(attributes.content, context);
        }
        catch (error) {
            errors[this.label] = error;
        }
        return { errors, parsed };
    }
    getName(content) {
        return this.arg.getName(content);
    }
}
exports.Command = Command;

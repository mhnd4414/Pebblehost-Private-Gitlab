"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const detritus_client_rest_1 = require("detritus-client-rest");
const { RestEvents } = detritus_client_rest_1.Constants;
const basecollection_1 = require("../collections/basecollection");
const constants_1 = require("../constants");
const structures_1 = require("../structures");
class RestClient extends detritus_client_rest_1.Client {
    constructor(token, options, client) {
        super(token, options);
        this.client = client;
        Object.defineProperty(this, 'client', { enumerable: false, writable: false });
        this.on(RestEvents.REQUEST, (payload) => this.client.emit(constants_1.ClientEvents.REST_REQUEST, payload));
        this.on(RestEvents.RESPONSE, (payload) => this.client.emit(constants_1.ClientEvents.REST_RESPONSE, payload));
    }
    async acceptTemplate(templateId, options) {
        const data = await super.acceptTemplate(templateId, options);
        let guild;
        if (this.client.guilds.has(data.id)) {
            guild = this.client.guilds.get(data.id);
            guild.merge(data);
        }
        else {
            guild = new structures_1.Guild(this.client, data);
            this.client.guilds.insert(guild);
        }
        return guild;
    }
    async createChannelInvite(channelId, options = {}) {
        const data = await super.createChannelInvite(channelId, options);
        return new structures_1.Invite(this.client, data);
    }
    async editChannelOverwrite(channelId, overwriteId, options = {}) {
        return super.editChannelOverwrite(channelId, overwriteId, options);
    }
    async createApplicationNews(options) {
        const data = await super.createApplicationNews(options);
        return new structures_1.ApplicationNews(this.client, data);
    }
    async createDm(options = {}) {
        const data = await super.createDm(options);
        let channel;
        if (this.client.channels.has(data.id)) {
            channel = this.client.channels.get(data.id);
            channel.merge(data);
            // this should never happen lmao
        }
        else {
            channel = structures_1.createChannelFromData(this.client, data);
            this.client.channels.insert(channel);
        }
        return channel;
    }
    async createGuild(options) {
        const data = await super.createGuild(options);
        let guild;
        if (this.client.guilds.has(data.id)) {
            guild = this.client.guilds.get(data.id);
            guild.merge(data);
        }
        else {
            guild = new structures_1.Guild(this.client, data);
            this.client.guilds.insert(guild);
        }
        return guild;
    }
    async createGuildChannel(guildId, options) {
        const data = await super.createGuildChannel(guildId, options);
        let channel;
        if (this.client.channels.has(data.id)) {
            channel = this.client.channels.get(data.id);
            channel.merge(data);
            // this should never happen lmao
        }
        else {
            channel = structures_1.createChannelFromData(this.client, data);
            this.client.channels.insert(channel);
        }
        return channel;
    }
    async createGuildEmoji(guildId, options) {
        const data = await super.createGuildEmoji(guildId, options);
        let emoji;
        if (this.client.emojis.has(guildId, data.id)) {
            emoji = this.client.emojis.get(guildId, data.id);
            emoji.merge(data);
        }
        else {
            data.guild_id = guildId;
            emoji = new structures_1.Emoji(this.client, data);
            this.client.emojis.insert(emoji);
        }
        return emoji;
    }
    async createGuildRole(guildId, options = {}) {
        const data = await super.createGuildRole(guildId, options);
        data.guild_id = guildId;
        const role = new structures_1.Role(this.client, data);
        if (this.client.guilds.has(guildId)) {
            this.client.guilds.get(guildId).roles.set(role.id, role);
        }
        return role;
    }
    async createGuildTemplate(guildId, options) {
        const data = await super.createGuildTemplate(guildId, options);
        return new structures_1.Template(this.client, data);
    }
    async createMessage(channelId, options = {}) {
        const data = await super.createMessage(channelId, options);
        if (this.client.channels.has(data.channel_id)) {
            const channel = this.client.channels.get(data.channel_id);
            if (channel.guildId) {
                data.guild_id = channel.guildId;
            }
        }
        const message = new structures_1.Message(this.client, data);
        this.client.messages.insert(message);
        return message;
    }
    async createOauth2ApplicationAsset(applicationId, options) {
        const data = await super.createOauth2ApplicationAsset(applicationId, options);
        data.application_id = applicationId;
        return new structures_1.Oauth2ApplicationAsset(this.client, data);
    }
    async createStoreApplicationAsset(applicationId, options) {
        const data = await super.createStoreApplicationAsset(applicationId, options);
        data.application_id = applicationId;
        return new structures_1.StoreApplicationAsset(this.client, data);
    }
    async createWebhook(channelId, options) {
        const data = await super.createWebhook(channelId, options);
        return new structures_1.Webhook(this.client, data);
    }
    async deleteChannel(channelId, options = {}) {
        const data = await super.deleteChannel(channelId, options);
        let channel;
        if (this.client.channels.has(data.id)) {
            channel = this.client.channels.get(data.id);
            this.client.channels.delete(data.id);
            channel.merge(data);
        }
        else {
            channel = structures_1.createChannelFromData(this.client, data);
        }
        return channel;
    }
    async deleteInvite(code, options = {}) {
        const data = await super.deleteInvite(code, options);
        return new structures_1.Invite(this.client, data);
    }
    /* Issue with merging data with these edited objects is that the gateway event wont have differences then */
    async editChannel(channelId, options = {}) {
        const data = await super.editChannel(channelId, options);
        let channel;
        if (this.client.channels.has(data.id)) {
            channel = this.client.channels.get(data.id);
            channel.merge(data);
        }
        else {
            channel = structures_1.createChannelFromData(this.client, data);
            // insert? nah
        }
        return channel;
    }
    async editGuild(guildId, options = {}) {
        const data = await super.editGuild(guildId, options);
        let guild;
        if (this.client.guilds.has(data.id)) {
            guild = this.client.guilds.get(data.id);
            guild.merge(data);
        }
        else {
            guild = new structures_1.Guild(this.client, data);
        }
        return guild;
    }
    async editGuildEmoji(guildId, emojiId, options = {}) {
        const data = await super.editGuildEmoji(guildId, emojiId, options);
        let emoji;
        if (this.client.emojis.has(guildId, data.id)) {
            emoji = this.client.emojis.get(guildId, data.id);
            emoji.merge(data);
        }
        else {
            data.guild_id = guildId;
            emoji = new structures_1.Emoji(this.client, data);
        }
        return emoji;
    }
    async editGuildRole(guildId, roleId, options = {}) {
        const data = await super.editGuildRole(guildId, roleId, options);
        let role;
        if (this.client.guilds.has(guildId)) {
            const guild = this.client.guilds.get(guildId);
            if (guild.roles.has(data.id)) {
                role = guild.roles.get(data.id);
                role.merge(data);
            }
            else {
                data.guild_id = guildId;
                role = new structures_1.Role(this.client, data);
                guild.roles.set(role.id, role);
            }
        }
        else {
            data.guild_id = guildId;
            role = new structures_1.Role(this.client, data);
        }
        return role;
    }
    async editGuildRolePositions(guildId, roles, options = {}) {
        const data = await super.editGuildRolePositions(guildId, roles, options);
        const collection = new basecollection_1.BaseCollection();
        if (this.client.guilds.has(guildId)) {
            const guild = this.client.guilds.get(guildId);
            guild.roles.clear();
            for (let raw of data) {
                raw.guild_id = guildId;
                const role = new structures_1.Role(this.client, raw);
                guild.roles.set(role.id, role);
                collection.set(role.id, role);
            }
        }
        else {
            for (let raw of data) {
                raw.guild_id = guildId;
                const role = new structures_1.Role(this.client, raw);
                collection.set(role.id, role);
            }
        }
        return collection;
    }
    async editMe(options = {}) {
        const data = await super.editMe(options);
        let user;
        if (this.client.user !== null) {
            user = this.client.user;
            user.merge(data);
        }
        else {
            user = new structures_1.UserMe(this.client, data);
        }
        return user;
    }
    async editMessage(channelId, messageId, options = {}) {
        const data = await super.editMessage(channelId, messageId, options);
        let message;
        if (this.client.messages.has(data.id)) {
            message = this.client.messages.get(data.id);
            message.merge(data);
            // should we really merge? the message_update event wont have differences then
        }
        else {
            message = new structures_1.Message(this.client, data);
            this.client.messages.insert(message);
        }
        return message;
    }
    async editTeam(teamId, options = {}) {
        return super.editTeam(teamId, options);
    }
    async editUser(options = {}) {
        return this.editMe(options);
    }
    async editWebhook(webhookId, options = {}) {
        const data = await super.editWebhook(webhookId, options);
        return new structures_1.Webhook(this.client, data);
    }
    async editWebhookToken(webhookId, token, options = {}) {
        const data = await super.editWebhookToken(webhookId, token, options);
        return new structures_1.Webhook(this.client, data);
    }
    async executeWebhook(webhookId, token, options = {}, compatibleType) {
        const data = await super.executeWebhook(webhookId, token, options, compatibleType);
        if (typeof (options) !== 'string' && options.wait) {
            const message = new structures_1.Message(this.client, data);
            this.client.messages.insert(message);
            return message;
        }
        return data;
    }
    async fetchApplicationNews(applicationIds) {
        const data = await super.fetchApplicationNews(applicationIds);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const applicationNews = new structures_1.ApplicationNews(this.client, raw);
            collection.set(applicationNews.id, applicationNews);
        }
        return collection;
    }
    async fetchApplicationNewsId(newsId) {
        const data = await super.fetchApplicationNewsId(newsId);
        return new structures_1.ApplicationNews(this.client, data);
    }
    async fetchApplication(applicationId) {
        const data = await super.fetchApplication(applicationId);
        return new structures_1.Application(this.client, data);
    }
    async fetchApplicationsDetectable() {
        const data = await super.fetchApplicationsDetectable.call(this);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const application = new structures_1.Application(this.client, raw);
            collection.set(application.id, application);
        }
        return collection;
    }
    async fetchChannel(channelId) {
        const data = await super.fetchChannel(channelId);
        let channel;
        if (this.client.channels.has(data.id)) {
            channel = this.client.channels.get(data.id);
            channel.merge(data);
        }
        else {
            channel = structures_1.createChannelFromData(this.client, data);
        }
        return channel;
    }
    async fetchChannelInvites(channelId) {
        const data = await super.fetchChannelInvites(channelId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const invite = new structures_1.Invite(this.client, raw);
            collection.set(invite.code, invite);
        }
        return collection;
    }
    async fetchChannelStoreListing(channelId) {
        const data = await super.fetchChannelStoreListing(channelId);
        return new structures_1.StoreListing(this.client, data);
    }
    async fetchChannelWebhooks(channelId) {
        const data = await super.fetchChannelWebhooks(channelId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const webhook = new structures_1.Webhook(this.client, raw);
            collection.set(webhook.id, webhook);
        }
        return collection;
    }
    async fetchDms(userId = '@me') {
        const data = await super.fetchDms(userId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let channel;
            if (this.client.channels.has(raw.id)) {
                channel = this.client.channels.get(raw.id);
                channel.merge(raw);
            }
            else {
                channel = structures_1.createChannelFromData(this.client, raw);
            }
            collection.set(channel.id, channel);
        }
        return collection;
    }
    async fetchGiftCode(code, options = {}) {
        const data = await super.fetchGiftCode(code, options);
        return new structures_1.Gift(this.client, data);
    }
    async fetchGuild(guildId) {
        const data = await super.fetchGuild(guildId);
        let guild;
        if (this.client.guilds.has(data.id)) {
            guild = this.client.guilds.get(data.id);
            guild.merge(data);
        }
        else {
            guild = new structures_1.Guild(this.client, data, { emojis: {}, members: {}, roles: {} });
        }
        guild.hasMetadata = true;
        return guild;
    }
    async fetchGuildAuditLogs(guildId, options = {}) {
        const data = await super.fetchGuildAuditLogs(guildId, options);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data.audit_log_entries) {
            let target = null;
            if (this.client.users.has(raw.target_id)) {
                target = this.client.users.get(raw.target_id);
                // target.merge(data.users.find((user) => user.id === raw.target_id));
            }
            else {
                let rawTarget = data.users.find((user) => user.id === raw.target_id);
                if (rawTarget !== undefined) {
                    target = new structures_1.User(this.client, rawTarget);
                }
                else {
                    rawTarget = data.webhooks.find((webhook) => webhook.id === raw.target_id);
                    if (rawTarget !== undefined) {
                        target = new structures_1.Webhook(this.client, rawTarget);
                    }
                }
            }
            let user = null;
            if (this.client.users.has(raw.user_id)) {
                user = this.client.users.get(raw.user_id);
            }
            else {
                const rawUser = data.users.find((u) => u.id === raw.user_id);
                if (rawUser !== undefined) {
                    user = new structures_1.User(this.client, rawUser);
                }
            }
            raw.guild_id = guildId;
            raw.target = target;
            raw.user = user;
            const auditLog = new structures_1.AuditLog(this.client, raw);
            collection.set(auditLog.id, auditLog);
        }
        return collection;
    }
    async fetchGuildBans(guildId) {
        const data = await super.fetchGuildBans(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let user;
            if (this.client.users.has(raw.user.id)) {
                user = this.client.users.get(raw.user.id);
                user.merge(raw.user);
            }
            else {
                user = new structures_1.User(this.client, raw.user);
            }
            collection.set(user.id, {
                reason: raw.reason,
                user,
            });
        }
        return collection;
    }
    async fetchGuildChannels(guildId) {
        const data = await super.fetchGuildChannels(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let channel;
            if (this.client.channels.has(raw.id)) {
                channel = this.client.channels.get(raw.id);
                channel.merge(raw);
            }
            else {
                channel = structures_1.createChannelFromData(this.client, raw);
            }
            collection.set(channel.id, channel);
        }
        return collection;
    }
    async fetchGuildEmoji(guildId, emojiId) {
        const data = await super.fetchGuildEmoji(guildId, emojiId);
        let emoji;
        if (this.client.emojis.has(guildId, data.id)) {
            emoji = this.client.emojis.get(guildId, data.id);
            emoji.merge(data);
        }
        else {
            data.guild_id = guildId;
            emoji = new structures_1.Emoji(this.client, data);
        }
        return emoji;
    }
    async fetchGuildEmojis(guildId) {
        const data = await super.fetchGuildEmojis(guildId);
        if (this.client.guilds.has(guildId)) {
            const guild = this.client.guilds.get(guildId);
            guild.merge({ emojis: data });
            return guild.emojis;
        }
        else {
            const collection = new basecollection_1.BaseCollection();
            for (let raw of data) {
                let emoji;
                if (this.client.emojis.has(guildId, raw.id)) {
                    emoji = this.client.emojis.get(guildId, raw.id);
                    emoji.merge(raw);
                }
                else {
                    raw.guild_id = guildId;
                    emoji = new structures_1.Emoji(this.client, raw);
                }
                collection.set(emoji.id || emoji.name, emoji);
            }
            return collection;
        }
    }
    async fetchGuildIntegrations(guildId) {
        const data = await super.fetchGuildIntegrations(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            raw.guild_id = guildId;
            const integration = new structures_1.Integration(this.client, raw);
            collection.set(integration.id, integration);
        }
        return collection;
    }
    async fetchGuildInvites(guildId) {
        const data = await super.fetchGuildInvites(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const invite = new structures_1.Invite(this.client, raw);
            collection.set(invite.code, invite);
        }
        return collection;
    }
    async fetchGuildMember(guildId, userId) {
        const data = await super.fetchGuildMember(guildId, userId);
        let member;
        if (this.client.members.has(guildId, userId)) {
            member = this.client.members.get(guildId, userId);
            member.merge(data);
        }
        else {
            data.guild_id = guildId;
            member = new structures_1.Member(this.client, data);
            this.client.members.insert(member);
        }
        return member;
    }
    async fetchGuildMembers(guildId, options = {}) {
        const data = await super.fetchGuildMembers(guildId, options);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let member;
            if (this.client.members.has(guildId, raw.user.id)) {
                member = this.client.members.get(guildId, raw.user.id);
                member.merge(raw);
            }
            else {
                raw.guild_id = guildId;
                member = new structures_1.Member(this.client, raw);
                this.client.members.insert(member);
            }
            collection.set(member.id, member);
        }
        return collection;
    }
    async fetchGuildPremiumSubscriptions(guildId) {
        const data = await super.fetchGuildPremiumSubscriptions(guildId);
        const subscriptions = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const subscription = new structures_1.PremiumSubscription(this.client, raw);
            subscriptions.set(subscription.id, subscription);
        }
        return subscriptions;
    }
    async fetchGuildRoles(guildId) {
        const data = await super.fetchGuildRoles(guildId);
        const collection = new basecollection_1.BaseCollection();
        if (this.client.guilds.has(guildId)) {
            const guild = this.client.guilds.get(guildId);
            for (let [roleId, role] of guild.roles) {
                if (!data.some((r) => r.id === roleId)) {
                    guild.roles.delete(roleId);
                }
            }
            for (let raw of data) {
                let role;
                if (guild.roles.has(raw.id)) {
                    role = guild.roles.get(raw.id);
                    role.merge(raw);
                }
                else {
                    raw.guild_id = guildId;
                    role = new structures_1.Role(this.client, raw);
                    guild.roles.set(role.id, role);
                }
                collection.set(role.id, role);
            }
        }
        else {
            for (let raw of data) {
                raw.guild_id = guildId;
                const role = new structures_1.Role(this.client, raw);
                collection.set(role.id, role);
            }
        }
        return collection;
    }
    async fetchGuildTemplates(guildId) {
        const data = await super.fetchGuildTemplates(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const template = new structures_1.Template(this.client, raw);
            collection.set(template.code, template);
        }
        return collection;
    }
    async fetchGuildWebhooks(guildId) {
        const data = await super.fetchGuildWebhooks(guildId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const webhook = new structures_1.Webhook(this.client, raw);
            collection.set(webhook.id, webhook);
        }
        return collection;
    }
    async fetchInvite(code, options = {}) {
        const data = await super.fetchInvite(code, options);
        return new structures_1.Invite(this.client, data);
    }
    async fetchMe(options = {}) {
        const data = await super.fetchMe.call(this, options);
        return new structures_1.UserMe(this.client, data);
    }
    async fetchMeChannels() {
        const data = await super.fetchMeChannels();
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let channel;
            if (this.client.channels.has(raw.id)) {
                channel = this.client.channels.get(raw.id);
                channel.merge(raw);
            }
            else {
                channel = structures_1.createChannelFromData(this.client, raw);
            }
            collection.set(channel.id, channel);
        }
        return collection;
    }
    async fetchMeConnections() {
        const data = await super.fetchMeConnections.call(this);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const account = new structures_1.ConnectedAccount(this.client, raw);
            collection.set(account.key, account);
        }
        return collection;
    }
    async fetchMeGuilds(options = {}) {
        const data = await super.fetchMeGuilds(options);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const guild = new structures_1.GuildMe(this.client, raw);
            collection.set(guild.id, guild);
        }
        return collection;
    }
    async fetchMessage(channelId, messageId) {
        const data = await super.fetchMessage(channelId, messageId);
        let guildId;
        if (this.client.channels.has(data.channel_id)) {
            const channel = this.client.channels.get(data.channel_id);
            if (channel.guildId) {
                guildId = channel.guildId;
            }
        }
        let message;
        if (this.client.messages.has(data.id)) {
            message = this.client.messages.get(data.id);
            message.merge(data);
        }
        else {
            data.guild_id = guildId;
            message = new structures_1.Message(this.client, data);
        }
        return message;
    }
    async fetchMessages(channelId, options = {}) {
        const data = await super.fetchMessages(channelId, options);
        let guildId;
        if (data.length) {
            const raw = data[0];
            if (this.client.channels.has(raw.channel_id)) {
                const channel = this.client.channels.get(raw.channel_id);
                if (channel.guildId) {
                    guildId = channel.guildId;
                }
            }
        }
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let message;
            if (this.client.messages.has(raw.id)) {
                message = this.client.messages.get(raw.id);
                message.merge(raw);
            }
            else {
                raw.guild_id = guildId;
                message = new structures_1.Message(this.client, raw);
            }
            collection.set(message.id, message);
        }
        return collection;
    }
    async fetchOauth2Applications() {
        const data = await super.fetchOauth2Applications.call(this);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const oauth2Application = new structures_1.Oauth2Application(this.client, raw);
            collection.set(oauth2Application.id, oauth2Application);
        }
        return collection;
    }
    async fetchOauth2Application(userId = '@me') {
        const data = await super.fetchOauth2Application(userId);
        let oauth2Application;
        if (userId === '@me') {
            if (this.client.application) {
                oauth2Application = this.client.application;
                oauth2Application.merge(data);
            }
            else {
                oauth2Application = new structures_1.Oauth2Application(this.client, data);
                this.client.application = oauth2Application;
            }
            if (oauth2Application.owner) {
                this.client.owners.clear();
                this.client.owners.set(oauth2Application.owner.id, oauth2Application.owner);
                if (oauth2Application.team) {
                    for (let [userId, member] of oauth2Application.team.members) {
                        this.client.owners.set(userId, member.user);
                    }
                }
            }
        }
        else {
            oauth2Application = new structures_1.Oauth2Application(this.client, data);
        }
        return oauth2Application;
    }
    async fetchOauth2ApplicationAssets(applicationId) {
        const data = await super.fetchOauth2ApplicationAssets(applicationId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            raw.application_id = applicationId;
            const asset = new structures_1.Oauth2ApplicationAsset(this.client, raw);
            collection.set(asset.id, asset);
        }
        return collection;
    }
    async fetchPinnedMessages(channelId) {
        const data = await super.fetchMessages(channelId);
        let guildId = null;
        if (data.length) {
            const raw = data[0];
            if (this.client.channels.has(raw.channel_id)) {
                const channel = this.client.channels.get(raw.channel_id);
                guildId = channel.guildId;
            }
        }
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let message;
            if (this.client.messages.has(raw.id)) {
                message = this.client.messages.get(raw.id);
                message.merge(raw);
            }
            else {
                raw.guild_id = guildId;
                message = new structures_1.Message(this.client, raw);
            }
            collection.set(message.id, message);
        }
        return collection;
    }
    async fetchStoreApplicationAssets(applicationId) {
        const data = await super.fetchStoreApplicationAssets(applicationId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            raw.application_id = applicationId;
            const asset = new structures_1.StoreApplicationAsset(this.client, raw);
            collection.set(asset.id, asset);
        }
        return collection;
    }
    async fetchReactions(channelId, messageId, emoji, options = {}) {
        const data = await super.fetchReactions(channelId, messageId, emoji, options);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            let user;
            if (this.client.users.has(raw.id)) {
                user = this.client.users.get(raw.id);
                user.merge(raw);
            }
            else {
                user = new structures_1.User(this.client, raw);
            }
            collection.set(user.id, user);
        }
        return collection;
    }
    async fetchTeam(teamId) {
        const data = await super.fetchTeam(teamId);
        return new structures_1.Team(this.client, data);
    }
    async fetchTeamMembers(teamId) {
        const data = await super.fetchTeamMembers(teamId);
        const collection = new basecollection_1.BaseCollection();
        for (let raw of data) {
            collection.set(raw.user.id, new structures_1.TeamMember(this.client, raw));
        }
        return collection;
    }
    async fetchTeamMember(teamId, userId) {
        const data = await super.fetchTeamMember(teamId, userId);
        return new structures_1.TeamMember(this.client, data);
    }
    async fetchTemplate(templateId) {
        const data = await super.fetchTemplate(templateId);
        return new structures_1.Template(this.client, data);
    }
    async fetchUser(userId) {
        const data = await super.fetchUser(userId);
        let user;
        if (this.client.users.has(data.id)) {
            user = this.client.users.get(data.id);
            user.merge(data);
        }
        else {
            user = new structures_1.User(this.client, data);
        }
        return user;
    }
    async fetchUserProfile(userId) {
        const data = await super.fetchUserProfile(userId);
        return new structures_1.Profile(this.client, data);
    }
    async fetchVoiceRegions(guildId) {
        const data = await super.fetchVoiceRegions(guildId);
        const regions = new basecollection_1.BaseCollection();
        for (let raw of data) {
            const region = new structures_1.VoiceRegion(this.client, raw);
            regions.set(region.id, region);
        }
        return regions;
    }
    async fetchWebhook(webhookId) {
        const data = await super.fetchWebhook(webhookId);
        return new structures_1.Webhook(this.client, data);
    }
    async fetchWebhookToken(webhookId, token) {
        const data = await super.fetchWebhookToken(webhookId, token);
        return new structures_1.Webhook(this.client, data);
    }
}
exports.RestClient = RestClient;

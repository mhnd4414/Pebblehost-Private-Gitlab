"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const detritus_client_rest_1 = require("detritus-client-rest");
const detritus_utils_1 = require("detritus-utils");
const client_1 = require("./client");
const processchild_1 = require("./cluster/processchild");
const basecollection_1 = require("./collections/basecollection");
const constants_1 = require("./constants");
class ClusterClient extends detritus_utils_1.EventSpewer {
    constructor(token, options = {}) {
        super();
        this.commandClient = null;
        this.manager = null;
        this.ran = false;
        this.shardCount = 0;
        this.shardEnd = -1;
        this.shardStart = 0;
        this.shards = new basecollection_1.BaseCollection();
        this.shardOptions = {};
        options = Object.assign({}, options);
        if (process.env.CLUSTER_MANAGER === 'true') {
            token = process.env.CLUSTER_TOKEN;
            options.shardCount = +process.env.CLUSTER_SHARD_COUNT;
            options.shards = [
                +process.env.CLUSTER_SHARD_START,
                +process.env.CLUSTER_SHARD_END,
            ];
        }
        if (!token) {
            throw new Error('Token is required for this library to work.');
        }
        this.token = token;
        this.shardCount = +(options.shardCount || this.shardCount);
        if (Array.isArray(options.shards)) {
            if (options.shards.length !== 2) {
                throw new Error('Shards need to be in the format of [shardStart, shardEnd]');
            }
            const [shardStart, shardEnd] = options.shards;
            this.shardEnd = +shardEnd;
            this.shardStart = +shardStart;
        }
        Object.assign(this.shardOptions, options);
        this.shardOptions.isBot = true;
        this.shardOptions.rest = Object.assign({}, this.shardOptions.rest);
        this.shardOptions.rest.authType = constants_1.AuthTypes.BOT;
        this.rest = new detritus_client_rest_1.Client(token, this.shardOptions.rest);
        this.shardOptions.rest.globalBucket = this.rest.globalBucket;
        this.shardOptions.rest.routesCollection = this.rest.routes;
        this.shardOptions.pass = Object.assign({}, this.shardOptions.pass);
        this.shardOptions.pass.cluster = this;
        if (this.shardOptions.pass.commandClient !== undefined) {
            this.commandClient = this.shardOptions.pass.commandClient;
        }
        if (process.env.CLUSTER_MANAGER === 'true') {
            this.manager = new processchild_1.ClusterProcessChild(this);
        }
        Object.defineProperties(this, {
            commandClient: { configurable: true, enumerable: false, writable: false },
            manager: { configurable: false, writable: false },
            ran: { configurable: true, writable: false },
            rest: { enumerable: false, writable: false },
            shardCount: { writable: false },
            shardEnd: { configurable: true, writable: false },
            shardStart: { configurable: true, writable: false },
            shards: { writable: false },
            shardOptions: { enumerable: false, writable: false },
            token: { enumerable: false, writable: false },
        });
    }
    setShardCount(value) {
        Object.defineProperty(this, 'shardCount', { value });
    }
    setShardEnd(value) {
        Object.defineProperty(this, 'shardEnd', { value });
    }
    setShardStart(value) {
        Object.defineProperty(this, 'shardStart', { value });
    }
    /** @hidden */
    _eval(code) {
        return eval(code);
    }
    kill(error) {
        for (let [shardId, shard] of this.shards) {
            shard.kill(error);
        }
        this.shards.clear();
        Object.defineProperty(this, 'ran', { value: false });
        this.emit(constants_1.ClientEvents.KILLED, { error });
        this.removeAllListeners();
    }
    hookedHasEventListener(shard, name) {
        return super.hasEventListener(name) || super.hasEventListener.call(shard, name);
    }
    hookedEmit(shard, name, event) {
        if (name !== constants_1.ClientEvents.READY) {
            if (this.hasEventListener(name)) {
                const clusterEvent = Object.assign({}, event, { shard });
                this.emit(name, clusterEvent);
            }
        }
        return super.emit.call(shard, name, event);
    }
    async run(options = {}) {
        if (this.ran) {
            return this;
        }
        options = Object.assign({
            delay: constants_1.DEFAULT_SHARD_LAUNCH_DELAY,
            url: process.env.GATEWAY_URL,
        }, options);
        const delay = options.delay;
        let shardCount = options.shardCount || this.shardCount || 0;
        if (options.url === undefined || !shardCount) {
            const data = await this.rest.fetchGatewayBot();
            shardCount = shardCount || data.shards;
            options.url = options.url || data.url;
        }
        if (!shardCount) {
            throw new Error('Shard Count cannot be 0, pass in one via the options or the constructor.');
        }
        this.setShardCount(shardCount);
        if (this.shardEnd === -1) {
            this.setShardEnd(shardCount - 1);
        }
        for (let shardId = this.shardStart; shardId <= this.shardEnd; shardId++) {
            const shardOptions = Object.assign({}, this.shardOptions);
            shardOptions.gateway = Object.assign({}, shardOptions.gateway, { shardCount, shardId });
            if (this.commandClient) {
                shardOptions.pass = Object.assign({}, shardOptions.pass);
                shardOptions.pass.commandClient = this.commandClient;
            }
            const shard = new client_1.ShardClient(this.token, shardOptions);
            Object.defineProperties(shard, {
                hasEventListener: { value: this.hookedHasEventListener.bind(this, shard) },
                emit: { value: this.hookedEmit.bind(this, shard) },
            });
            this.shards.set(shardId, shard);
            this.emit(constants_1.ClientEvents.SHARD, { shard });
            await shard.run(options);
            if (shardId < this.shardEnd) {
                await detritus_utils_1.Timers.sleep(delay);
            }
        }
        Object.defineProperty(this, 'ran', { value: true });
        this.emit(constants_1.ClientEvents.READY);
        return this;
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
}
exports.ClusterClient = ClusterClient;
